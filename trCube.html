<!-- (CC-NC-BY) μ—¬μΈν 2019 -->
<html>

<head>
	<title>WebGLHelloAPI</title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
	<script type="text/javascript" src="trCube
.js"></script>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body bgcolor='#f1f1f1' onload="main()">
	<header>
		welcome to my WebGL!
	</header>

	<nav>
		<canvas id="helloapicanvas" style="border: none;" width="400" height="400"></canvas>
		<br>
	</nav>

	<article>
		<ul>
			<li>
				<a onclick="Transformation.style.display=(Transformation.style.display=='none')?'block':'none';"
					href="javascript:void(0)">
					<big>Transformation</big>
				</a>
			</li>
			<li>
				<a onclick="Texture.style.display=(Texture.style.display=='none')?'block':'none';"
					href="javascript:void(0)">
					<big>Texture Mapping</big>
				</a>
			</li>

			<li>
				<a onclick="ZBuffer.style.display=(ZBuffer.style.display=='none')?'block':'none';"
					href="javascript:void(0)">
					<big>Z-Buffering</big>
				</a>
			</li>
		</ul>

		<div style="DISPLAY: none" id="Transformation">
			<br><br>
			<t>
				Geometric data such as vertex positions and normal vectors are transformed via Vertex Operation <br>
				and Primitive Assembly operation in OpenGL pipeline before raterization process.
			</t><br>
			<img src="pipeline.png"><br><br>

			<big><b>Translation</b></big>&nbsp;&nbsp;
			<button id="trans" onclick="clickbutton(translation)">Source Code</button>

			<p>
				A translation moves a vector a certain distance in a certain direction.
			</p>
			<img src="translate.png"><br><br>

			<t>tx:</t>
			<input type="text" id="xTranslate" maxlength="4" style=width:30px;>
			<t>ty:</t>
			<input type="text" id="yTranslate" maxlength="4" style=width:30px;>
			<t>tz:</t>
			<input type="text" id="zTranslate" maxlength="4" style=width:30px;>
			<button onclick="submitTrans(xTranslate.value, yTranslate.value, zTranslate.value)">Translate!</button>
			<button onclick="resetTrans()">Reset</button><br><br>

			<big><b>Rotation</b></big>&nbsp;&nbsp;
			<button id="rotation" onclick="clickbutton(rotate)">Source Code</button>


			<p>
				A rotation transformation rotates a vector around the origin (0,0,0) using a given axis and angle.
			</p>
			<img src="rotate.png"><br><br>

			<button onclick="rotateShape(1)">X Rotate Speed + 0.01</button>
			<button onclick="rotateShape(2)">Y Rotate Speed + 0.01</button>
			<button onclick="rotateShape(3)">Z Rotate Speed + 0.01</button>
			<button onclick="rotateShape(4)">Axis Rotate Speed + 0.01</button>



			<button onclick="stopRotate()">Stop Rotate</button>



		</div>
		<br>
		<div style="DISPLAY: none" id=Texture>

			<br>
			<button onclick="insertImage()">Input Image&nbsp&nbsp </button>&nbsp;
			<button onclick="deleteImage()">Delete Image</button>
			<p>
				The pixels in the texture will be addressed using texture coordinates during drawing operations.<br>
				These coordinates range from 0.0 to 1.0 where (0,0) is conventionally the bottom-left corner and<br>
				(1,1) is the top-right corner of the texture image.
			</p>
			<big><b>Wrapping</b></big>&nbsp;&nbsp;
			<button id="wrapping" onclick="clickbutton(textureMapping)">Source Code</button>

			<p>
				GL_REPEAT: The integer part of the coordinate will be ignored and a repeating pattern is formed.<br>
				GL_MIRRORED_REPEAT: The texture will also be repeated, but it will be mirrored when the integer part of
				the coordinate is odd.<br>
				GL_CLAMP_TO_EDGE: The coordinate will simply be clamped between 0 and 1.
			</p>

			<input type="radio" name="radio_answer" value="1" oninput="Wrapping(this.value)" />
			<font>Texture_Wrap_S</font>
			<input type="radio" name="radio_answer" value="2" oninput="Wrapping(this.value)" />
			<font>Texture_Wrap_T</font>
			<input type="radio" name="radio_answer" value="3" checked oninput=" Wrapping(this.value)" />
			<font>Both</font><br><br>

			<button onclick="repeatImage()">Repeat Image</button>
			<button onclick="mirrorImage()">Mirrored Repeat Image</button>
			<button onclick="clampImage()">Clamp Edge Image</button>

		</div>
		<br>
		<div style="DISPLAY: none" id="ZBuffer">

			<t>
				z-buffering, also known as depth buffering, is the management of image depth coordinates in 3D
				graphics,<br>
				In a 3d-rendering engine, when an object is projected on the screen,<br>
				the depth (z-value) of a generated pixel in the projected screen image is stored in a buffer (the<br>
				z-buffer or depth buffer).<br>
				A z-value is the measure of the perpendicular distance from a pixel on the projection plane to its<br>
				corresponding 3d-coordinate on a polygon in world-space.<br>
				When viewing an image containing partially or fully overlapping opaque objects or surfaces,<br>
				it is not possible to fully see those objects that are furthest away from the viewer and behind
				other<br>
				objects
			</t><br><br>

			<t id="zoom"> Zoom in/out : 5 </t>&nbsp&nbsp
			<t id="projection"> projection : 7</t><br>
			<input type="range" value="500" min="250" max="750" oninput="zoomValue(this.value)">
			<input type="range" value="700" min="400" max="1000" oninput="projectionValue(this.value)">

		</div>
	</article>
	<footer>
		<button onclick="changetoTetrahedron()">Tetrahedron </button>&nbsp;
		<button onclick="changetoCube()">Cube </button>&nbsp;
		<table border=1>
			<tr>
				<td id="matrix0">
				<td id="matrix4">
				<td id="matrix8">
				<td id="matrix12">
			<tr>
				<td id="matrix1">
				<td id="matrix5">
				<td id="matrix9">
				<td id="matrix13">
			<tr>
				<td id="matrix2">
				<td id="matrix6">
				<td id="matrix10">
				<td id="matrix14">
			<tr>
				<td id="matrix3">
				<td id="matrix7">
				<td id="matrix11">
				<td id="matrix15">
		</table>
		<p id="webTrX"> translate (0.0,0.0,0.0) </p>

	</footer>
	</div>

	<!-- Source Code Section Using Modal -->
	<!-- Modal content -->
	<div id="textureMapping" class="modal">
		<div class="modal-content">
			<span class="close" onclick="clickspan(textureMapping)">&times;</span>
			<pre>
// Initialize Buffer			
// Input image
var texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);

// Fill the texture with a 1x1 blue pixel.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
new Uint8Array([0, 0, 255, 255]));

// Asynchronously load an image
var image = new Image();
image.src = "";
image.addEventListener('load', function() {

// Now that the image has loaded make copy it to the texture.
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);
gl.generateMipmap(gl.TEXTURE_2D);
});

// When click Clamp Edge Image button
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);

// When click Mirrored Repeat Image button
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.MIRRORED_REPEAT);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT);
-----------------------------------------------------------------------------------------
// Fragment Shader 
var fragmentShaderSource = '\
varying mediump vec4 color; \
varying mediump vec2 texCoord;\
uniform sampler2D sampler2d; \
void main(void) \
{ \
	gl_FragColor = texture2D(sampler2d, texCoord);\
}';


		</pre>
		</div>
	</div>

	<div id="translation" class="modal">
		<div class="modal-content">
			<span class="close" onclick="clickspan(translation)">&times;</span>
			<pre>
// multiplication function
function translate(m, tx, ty, tz) {
	var tm = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	tm[12] = tx; tm[13] = ty; tm[14] = tz;
	mulMatrix(m, tm);
}
				

-----------------------------------------------------------------------------------------
// renderscene		
var Pmatrix = gl.getUniformLocation(gl.programObject, "Pmatrix");
var Vmatrix = gl.getUniformLocation(gl.programObject, "Vmatrix");
var Mmatrix = gl.getUniformLocation(gl.programObject, "Mmatrix");

idMatrix(mov_matrix); // create matrix
translate(mov_matrix, transX, transY, transZ);
gl.uniformMatrix4fv(Mmatrix, false, mov_matrix);
-----------------------------------------------------------------------------------------
// vertex shader
var vertexShaderSource = '\
	attribute highp vec3 myVertex; \
	attribute highp vec4 myColor; \
	uniform mediump mat4 Pmatrix; \
	uniform mediump mat4 Vmatrix; \
	uniform mediump mat4 Mmatrix; \
	varying mediump vec4 color; \
	void main(void)  \
	{ \
		gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(myVertex, 1.0);\
		color = myColor;\
	}';

gl.vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(gl.vertexShader, vertexShaderSource);
gl.compileShader(gl.vertexShader);
			</pre>
		</div>
	</div>

	<div id="rotate" class="modal">
			<div class="modal-content">
				<span class="close" onclick="clickspan(rotate)">&times;</span>
				<pre>


	
				</pre>
			</div>
		</div>

</body>

</html>